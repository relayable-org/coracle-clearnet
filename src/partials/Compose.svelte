<script lang="ts">
  import {nip19} from "nostr-tools"
  import {last, pluck, propEq} from "ramda"
  import {fuzzy} from "src/util/misc"
  import {displayPerson} from "src/util/nostr"
  import Badge from "src/partials/Badge.svelte"
  import ContentEditable from "src/partials/ContentEditable.svelte"
  import Suggestions from "src/partials/Suggestions.svelte"
  import {watch} from "src/agent/storage"
  import {getPubkeyWriteRelays} from "src/agent/relays"

  export let onSubmit

  let contenteditable, suggestions

  const pubkeyEncoder = {
    encode: pubkey => {
      const relays = pluck("url", getPubkeyWriteRelays(pubkey))
      const nprofile = nip19.nprofileEncode({pubkey, relays})

      return "nostr:" + nprofile
    },
    decode: link => {
      // @ts-ignore
      return nip19.decode(last(link.split(":"))).data.pubkey
    },
  }

  const searchPeople = watch("people", t => {
    return fuzzy(t.all({"kind0.name:!nil": null}), {keys: ["kind0.name", "pubkey"]})
  })

  const applySearch = word => {
    suggestions.setData(word.startsWith("@") ? $searchPeople(word.slice(1)).slice(0, 5) : [])
  }

  const getInfo = () => {
    const selection = window.getSelection()
    const {focusNode: node, focusOffset: offset} = selection
    const textBeforeCursor = node.textContent.slice(0, offset)
    const word = last(textBeforeCursor.trim().split(/\s+/))

    return {selection, node, offset, word}
  }

  const autocomplete = ({person}) => {
    const {selection, node, offset, word} = getInfo()

    const annotate = (prefix, text, value) => {
      const adjustedOffset = offset - word.length + prefix.length

      // Space includes a zero-width space to avoid having the cursor end up inside
      // mention span on backspace, and a space for convenience in composition.
      const space = document.createTextNode("\u200B\u00A0")
      const span = document.createElement("span")

      span.classList.add("underline")
      span.dataset.coracle = JSON.stringify({prefix, value})
      span.innerText = text

      // Remove our partial mention text
      selection.setBaseAndExtent(node, adjustedOffset, node, offset)
      selection.deleteFromDocument()

      // Add the span and space
      selection.getRangeAt(0).insertNode(span)
      selection.collapse(span.nextSibling, 0)
      selection.getRangeAt(0).insertNode(space)
      selection.collapse(space, 2)
    }

    // Mentions
    if (word.length > 1 && word.startsWith("@")) {
      annotate("@", displayPerson(person).trim(), pubkeyEncoder.encode(person.pubkey))
    }

    // Topics
    if (word.length > 1 && word.startsWith("#")) {
      annotate("#", word.slice(1), word.slice(1))
    }

    suggestions.setData([])
  }

  const onKeyDown = e => {
    if (e.code === "Enter" && (e.ctrlKey || e.metaKey)) {
      return onSubmit()
    }

    // Don't close a modal, submit the form, or lose focus
    if (["Escape", "Tab"].includes(e.code)) {
      e.preventDefault()
      e.stopPropagation()
    }

    // If we have suggestions, re-route keyboard commands
    if (suggestions.get() && ["Enter", "ArrowUp", "ArrowDown"].includes(e.code)) {
      e.preventDefault()
    }

    // Enter adds a newline, so do it on key down
    if (["Enter"].includes(e.code)) {
      autocomplete({person: suggestions.get()})
    }
  }

  const onKeyUp = e => {
    const {word} = getInfo()

    // Populate search data
    applySearch(word)

    if (["Tab"].includes(e.code)) {
      autocomplete({person: suggestions.get()})
    }

    if (["Escape", "Space"].includes(e.code)) {
      suggestions.clear()
    }

    if (e.code === "ArrowUp") {
      suggestions.prev()
    }

    if (e.code === "ArrowDown") {
      suggestions.next()
    }
  }

  export const mention = person => {
    const input = contenteditable.getInput()
    const selection = window.getSelection()
    const textNode = document.createTextNode("@")
    const spaceNode = document.createTextNode(" ")

    // Insert the text node, then an extra node so we don't break stuff in annotate
    selection.getRangeAt(0).insertNode(textNode)
    selection.collapse(input, 1)
    selection.getRangeAt(0).insertNode(spaceNode)
    selection.collapse(input, 1)

    autocomplete({person})
  }

  const createNewLines = (n = 1) => {
    const div = document.createElement("div")

    div.innerHTML = "<br>".repeat(n)

    return div
  }

  export const nevent = text => {
    const input = contenteditable.getInput()
    const selection = window.getSelection()
    const textNode = document.createTextNode(text)
    const newLines = createNewLines(2)

    selection.getRangeAt(0).insertNode(textNode)
    selection.collapse(input, 1)
    selection.getRangeAt(0).insertNode(newLines)
    selection.collapse(input, 2)
  }

  export const parse = () => {
    let {content, annotations} = contenteditable.parse()
    const topics = pluck("value", annotations.filter(propEq("prefix", "#")))

    // Remove zero-width and non-breaking spaces
    content = content.replace(/[\u200B\u00A0]/g, " ").trim()

    // We're still using old style mention interpolation until NIP-27
    // gets merged https://github.com/nostr-protocol/nips/pull/381/files
    const mentions = annotations.filter(propEq("prefix", "@")).map(({value}, index) => {
      content = content.replace("@" + value, `#[${index}]`)

      return pubkeyEncoder.decode(value)
    })

    return {content, topics, mentions}
  }
</script>

<div class="flex">
  <ContentEditable bind:this={contenteditable} on:keydown={onKeyDown} on:keyup={onKeyUp} />
  <slot name="addon" />
</div>

<Suggestions bind:this={suggestions} select={person => autocomplete({person})}>
  <div slot="item" let:item>
    <Badge inert person={item} />
  </div>
</Suggestions>
